# SOLID-SoftwareLab-
<div style="text-align: right"> 
در این پیاده‌سازی، با استفاده از کلاس abstract، هر دو اصل OCP و LSP را رعایت کرده‌ام. به این شکل که اگر مربع را زیرکلاس مستطیل قرار می‌دادم، اولا برای ساخت مربع، باید precondition بیشتری از پدر برقرار می‌شد که برابر بودن عرض و طول  بود که باعث می‌شد مربع همه جا نتواند نوعی مستطیل باشد و LSP نقض می‌شد و از طرفی، اگر به عنوان مثال در آینده تابعی برای افزایش مساحت مستطیل می‌خواستیم که به عنوان مثال x درصد افزایش داشته باشد، کافی بود یکی از اضلاع را x درصد افزایش دهیم در صورتی که این باعث می‌شود که مساحت مربع بیشتر افزایش پیدا کند و این ویژگی مستطیل برای مربع صادق نخواهد بود که نشان می‌دهد کد ما نسبت به extension بسته است یا اگر چیزی اضافه کنیم، نیازمند modification هستیم که نقض اصل OCP است
<bold> سوالات </bold>
<ol>
   <li>
     این اصول به این ترتیب هستند
<br> 
<par>
SRP: یک کلاس یا ماژول باید تنها یک دلیل برای تغییر داشته باشد، یعنی باید نسبت به یک actor واحد مسئولیت داشته باشد. این منجر به سازماندهی بهتر کد، تست آسان تر و وابستگی کمتر به ماژول ها یا کلاس های دیگر می شود
</par>
<br> 
<par>
OCP: موجودیت‌های نرم‌افزار (کلاس‌ها، ماژول‌ها، توابع و غیره) باید برای توسعه باز باشند اما برای تغییر بسته باشند. این بدان معنی است که عملکردهای جدید باید بتواند از طریق کلاس های مشتق شده جدید، بدون تغییر کلاس های موجود، اضافه شود.
</par>
<br> 
<par>
LSP: زیرکلاس ها باید بدون تغییر در صحت برنامه قابل جایگزین شدن با اجداد خود باشند. این تضمین می‌کند که کلاس‌های مشتق‌شده می‌توانند بدون تأثیر بر رفتار برنامه جایگزین کلاس‌های پایه شوند و قابلیت استفاده مجدد و نگهداری را ارتقا دهند و precondition بیشتری ندارند و ممکن است postconditon بیشتری فراهم کنند.
</par>
<br> 
<par>
ISP: کلاینت ها نباید مجبور شوند به واسط هایی که استفاده نمی کنند وابسته شوند. این اصل ایجاد رابط های کوچکتر و متمرکزتر را تشویق می کند که منجر به کدهای قابل نگهداری و انعطاف پذیرتر می شود. در واقع واسط‌های کوچک و متعدد که هر یک کار خود را انجما می‌دهند، اولویت دارد بر یک واسط کلی که همه مجبور به استفاده از آن باشند.
</par>
<br> 
<par>
DIP: ماژول های سطح بالا نباید به ماژول های سطح پایین وابسته باشند. هر دو باید به انتزاعات بستگی داشته باشند. این اصل جداسازی را ترویج می‌کند و امکان تغییرات آسان‌تر کد را فراهم می‌کند، زیرا وابستگی‌ها از طریق انتزاع‌ها مدیریت می‌شوند تا پیاده‌سازی عینی و به طور کلی وابستگی‌ها به سمت کلاس‌های انتزاعی‌تر می‌روند.
</par>
   </li>
   <li>
در واقع استفاده این اصول، در مراحل طراحی و پیاده سازی بسیار پررنگ تر است. در مرحله طراحی، اصول SOLID به ایجاد یک معماری نرم افزاری قوی و موثر کمک می کند. این اصول توسعه دهندگان را در سازماندهی کلاس ها و رابط های خود راهنمایی می کنند تا اطمینان حاصل شود که هر جزء دارای مسئولیت در قبال یک actor واحد است، به اصل OCP پایبند است و از اصل جایگزینی Liskov پیروی می کند. این منجر به طراحی ماژولارتر و قابل نگهداری تر می شود. در مرحله پیاده سازی، که شامل نوشتن کد است، توسعه دهندگان اصول SOLID را برای ایجاد کد تمیز، قابل نگهداری و مقیاس پذیر اعمال می کنند. با رعایت این اصول، توسعه‌دهندگان می‌توانند اتصال بین اجزای مختلف را کاهش دهند، و اصلاح، گسترش و ریفکتور کد را در صورت نیاز آسان‌تر کنند. 
   </li>  
   <li>
خیر متناقض نیستند، بلکه رویکردهای متفاوتی را برای توسعه و تست نرم افزار نشان می دهند. TDD یک رویکرد کارآمدتر و قابل اعتمادتر برای توسعه نرم افزار ارائه می دهد و اطمینان حاصل می کند که کد قبل از ادغام در سیستم به طور کامل تست شده است. آزمایش سنتی ممکن است برای اسکوپ‌های بزرگتر و پیچیده‌تر مناسب‌تر باشد، جایی که رویکرد جامع‌تری برای آزمایش مورد نیاز است. 
   </li>
    <li>
 در این پروژه خاص، در آن صورت، می‌شد مربع را از مستطیل به ارث برد چون ابعاد بعد از مقداردهی اولیه ثابت می‌ماندند. 
   </li>
   
</ol> 
</div>
